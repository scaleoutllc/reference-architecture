#!/bin/bash
# A convenience script for calculating terraform workspace dependencies.
set -euo pipefail
SCRIPT_PATH="$(cd "$(dirname "$BASH_SOURCE[0]")"; pwd -P)"

# If you have to edit this, good fucking luck.
function tracedeps {
jq -r --arg target "$1" '
.groups as $data |

# traverse all groups for a given target and return an array of them.
def findGroups($target):
  if $data[$target] | has("groups") then
    ($data[$target].groups + ($data[$target].groups | map(findGroups(.)) | flatten)) | unique
  else
    []
  end;

# find the deepest level of nested workspaces within a set of groups.
def deepestInGroup($targets):
  $targets | 
  if length > 0 then
    map($data[.] | 
      [path(.. | select(objects | has("next") | not))] | last | join(".next.")) | 
        max_by(split(".") | length) |
          split(".") + ["workspaces"]
  end | if length == 1 then
    ["next", "workspaces"]
  end;

# if a target defines both groups and workspaces the groups must complete
# building before the workspace runs. this moves the workspaces defined
# to be run to a level of nesting deeper than any workspaces in the groups.
def moveWorkspaceDeepestInGroup($target):
  deepestInGroup(findGroups($target)) as $key |
  if length > 0 and $data[$target].groups then
      $data[$target] * (
        {} | setpath($key; $data[$target].workspaces)
      ) | del(.workspaces)
  else    
    $data[target]
  end * {"name":$target} | del(.groups);

# this deep merges two objects. if an array element in exists in both objects
# the array in the merged object is a concatenation of both arrays.
def mergeConcat(a; b):
  a as $a | b as $b
  | if ($a|type) == "object" and ($b|type) == "object"
    then reduce ([$a,$b]|add|keys_unsorted[]) as $k ({}; 
      .[$k] = mergeConcat($a[$k]; $b[$k]))
    elif ($a|type) == "array" and ($b|type) == "array"
    then $a+$b
    elif $b == null then $a
    else $b
    end;

# deep merge an array of objects representing all the targets to do work on.
def collapse:
  reduce .[] as $i ({}; mergeConcat(.; $i));
  
# extract all the workspaces at each level of nesting and produce an array
# that represnts each stage of work that can be performed in parallel.
def collect:
  [.. | objects | select(has("workspaces")) | .workspaces | join(" ")] | join("\n");

# produce the dependency graph. each line is a space separated list of
# workspaces that can be applied in parallel.
(
  [moveWorkspaceDeepestInGroup($target)] + 
  (findGroups($target) | map(moveWorkspaceDeepestInGroup(.)))
) | collapse | collect
'
}

# Read in the Infrafile.
INFRAFILE=$(spruce json "${SCRIPT_PATH}/../Infrafile")

# Execute jq script with the target group "test"
echo "$INFRAFILE" | tracedeps "$1"
